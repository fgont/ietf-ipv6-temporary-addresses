<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?> <!-- used by XSLT processors -->
<!-- OPTIONS, known as processing instructions (PIs) go here. -->
<?rfc toc="yes" ?>
<?rfc tocompact="yes"?>
<!-- If "yes" eliminates blank lines before main section entries. -->
<?rfc tocdepth="1"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc strict="no" ?>
<rfc category="std" docName="draft-gont-6man-non-stable-iids-01" 
ipr="trust200902" updates="RFC4941">

<front>
<title abbrev="Temporary Interface-IDs">
Recommendation on Temporary IPv6 Interface Identifiers</title>

    <author fullname="Fernando Gont" initials="F." surname="Gont">
      <organization abbrev="SI6 Networks / UTN-FRH">SI6 Networks / UTN-FRH</organization>

      <address>
        <postal>
          <street>Evaristo Carriego 2644</street>

          <code>1706</code>

          <city>Haedo</city>

          <region>Provincia de Buenos Aires</region>

          <country>Argentina</country>
        </postal>

        <phone>+54 11 4650 8472</phone>

        <email>fgont@si6networks.com</email>

        <uri>http://www.si6networks.com</uri>
      </address>
    </author>


 <author fullname="Christian Huitema" initials="C." surname="Huitema">
    <organization>Private Octopus Inc.</organization>
    <address>
      <postal>
        <street></street>
        <city>Friday Harbor</city>
        <code>98250</code>
        <region>WA</region>
        <country>U.S.A.</country>
      </postal>
      <email>huitema@huitema.net</email>
      <uri>http://privateoctopus.com/</uri>
    </address>
  </author>

    <author fullname="Guillermo Gont" initials="G.G." surname="Gont">
      <!-- abbrev not needed but can be used for the header
         if the full organization name is too long -->

      <organization abbrev="SI6 Networks">SI6 Networks</organization>

      <address>
        <postal>
          <!-- I've omitted my street address here -->

          <street>Evaristo Carriego 2644</street>

          <code>1706</code>

          <city>Haedo</city>

          <region>Provincia de Buenos Aires</region>

          <country>Argentina</country>
        </postal>

        <phone>+54 11 4650 8472</phone>

        <email>ggont@si6networks.com</email>

        <uri>https://www.si6networks.com</uri>
      </address>
    </author>	

    <author fullname="Madeleine Garcia Corbo" initials="M." surname="Garcia Corbo">
      <organization abbrev="SITRANS">Servicios de Informacion del Transporte</organization>

      <address>
        <postal>
          <street>Neptuno 358</street>
          <code>10400</code>
          <city>Havana City</city>
          <country>Cuba</country>
        </postal>

        <email>madelen.garcia16@gmail.com</email>
      </address>
    </author>


<date/>
<area>Internet</area>
<workgroup>IPv6 maintenance Working Group (6man)</workgroup>
    <abstract>
    <t>
This document clarifies the stability requirements for IPv6 addresses, and provides recommendations regarding the generation of Temporary addresses. Finally, it formally updates RFC4941 such that nodes are allowed to configure only temporary addresses.
    </t>
    </abstract>
  </front>

  <middle>
  
  
<section title="Introduction" anchor="intro">
<t>IPv6 StateLess Address AutoConfiguration (SLAAC) <xref target="RFC4862"/> 
has traditionally resulted in stable addresses, since the Interface Identifier (IID) 
has been generated by embedding a stable layer-2 numeric identifier (e.g., a MAC 
address). <xref target="RFC4941"/> implies, throughout the  specification, that 
temporary addresses are generated and employed along with temporary addresses.
</t>

<!--
[RFC4941]:
   Addresses generated using stateless address autoconfiguration
   [ADDRCONF] contain an embedded interface identifier, which remains
   constant over time.


[....]

   1.  Do not result in any changes to the basic behavior of addresses
       generated via stateless address autoconfiguration [ADDRCONF].
-->

<t>While the use of stable addresses (only) or mixed stable and temporary 
addresses can be desirable in a number of scenarios, there are other scenarios 
in which, for security and privacy reasons, a node may want to use only Temporary 
address (e.g., a temporary address).</t>

<t>This document clarifies the requirements for stability of IPv6 addresses, such 
that nodes are not required to configure stable addresses. It also specifies a set 
of requirements for the generation of Temporary addresses, and also specifies some sample algorithms that may be employed to generate temporary addresses that comply with the aforementioned requirements. Finally, it formally 
updates <xref target="RFC4941"/> such that temporary addresses can be employed 
without the need to configure a stable address along side.
</t>
</section>


<section title="Terminology" anchor="terminology">

<t>This document employs the terms defined in <xref target="RFC7721"/>.</t>


<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
   NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   RFC 2119 <xref target="RFC2119"/>.</t>
</section>

<section title="Problem statement" >
<t>
When <xref target="RFC4941"/> was written, its authors wanted to prevent privacy and security
attacks enabled by addresses that contain "an embedded interface identifier, which remains
constant over time". They observed that "Anytime a fixed identifier is used in multiple
contexts, it becomes possible to correlate seemingly unrelated activity using this identifier." 
They were concerned with both on-path attackers who would observe the IP addresses of
packets observed in transit, and attackers that would have access to the logs of servers.
</t>
<t>
Since the publication of <xref target="RFC4941"/> in September 2007, our understanding of threats
and mitigations has evolved. The IETF is now officially concerned with Pervasive Monitoring 
<xref target="RFC7258" />, as well as the wide spread collection of information for
advertising and other purposes, for example through the Real Time Bidding protocol used for 
advertising auctions <xref target="RTB25" />.
</t>
<section title="Privacy requirements" anchor="privacy-reqs">
<t>
The widespread deployment of encryption advocated in <xref target="RFC7624" /> is a 
response to Pervasive Monitoring. Encryption of communication reduces the amount of
information that can be collected by monitoring data links, but does not prevent
monitoring of IPv6 addresses embedded in clear text packet headers. Stable IPv6 addresses
enable the correlation of such data over time. 
</t>
<t>
MAC Address Randomization <xref target="IETFMACRandom" />
is another response to pervasive monitoring. In conjunction with
DHCP Anonymity <xref target="RFC7844" />, it ensures that devices cannot be tracked by their
MAC Address or their DHCP identifiers when they connect to "hot spots". However, the privacy
effects of MAC Address Randomization would be nullified if a device kept using the
same IPv6 address before and after a MAC-address randomization event.
</t>
<t>
Many Web Browsers have options enabling browsing "in private". However,
if the web connections during the private mode use the same IPv6 address as those
in the public mode, web tracking systems similar to <xref target="RTB25" /> will quickly
find the correlation between the public personna of the user and the supposedly
private connection. Similarly, many web browsers have options to "delete history",
including deleting "cookies" and other persistent data. Again, if the same IPv6 address
is used before and after the deletion of cookies, web tracking systems will 
easily correlate the new activity with the prior data collection.
</t>
<t>
Using temporary address alone may not be sufficient to prevent all forms of tracking. It
is however quite clear that some usage of temporary addresses is necessary to
provide user privacy. It is also clear that the usage of temporary addresses needs
to be synchronized with other privacy defining event such as moving to a new network,
performing MAC Address Randomization, or changing the privacy posture of a node.
</t>
</section>

<section title="Stability Requirements for IPv6 Addresses" anchor="iid-generation">
<t>Nodes are not required to generate addresses with any specific stability properties. 
That is, the generation of stable addresses is OPTIONAL. This means that a node may end 
up configuring only stable addresses, only Temporary, or both stable and temporary addresses.
</t>
</section>


<section title="Requirements for Temporary IPv6 Addresses" anchor="non-iid-generation">
<t>The requirements for temporary IPv6 addresses are as follows:
<list style="numbers">
<t>Temporary addresses MUST have a limited lifetime, which should be different for different addresses. The lifetime of an address essentially limits the extent to which network activity correlation can be performed based on such address.</t>
<t>The lifetime of an address MUST be further reduced when privacy-meaningful events (such as a node attaching to a new network) takes place.</t>
<t>The resulting Interface Identifiers MUST be different when addresses are configured 
   for different prefixes.  That is, if different
   autoconfiguration prefixes are used to configure addresses for the same
   network interface card, the resulting Interface Identifiers must be
   (statistically) different.  This means that, given two addresses that employ different prefixes, it must
   be difficult for an outside entity to tell whether the addresses correspond to the same network interface or even whether they have been
   generated by the same host.
</t>

<t>The resulting interface identifiers MUST NOT embed layer-2 identifiers (e.g. MAC 
addresses).</t>



<t>It must be difficult for an outside entity to predict the Interface
   Identifiers that will be generated by the algorithm, even with knowledge
   of the Interface Identifiers generated for configuring other addresses.
</t>

<t>The resulting Interface Identifiers MUST be semantically opaque <xref target="RFC7136"/> and MUST NOT 
follow any specific patterns.</t>

</list> 
</t>

<t>By definition, temporary addresses have a limited lifetime. This is in contrast with e.g. stable addresses <xref target="RFC7217"/>, that do not have have a limited lifetime. Having a variable maximum lifetime prevents an observer from synchronizing with the temporary address regeneration; that is, from being able to expect when address will be regenerated, and thus infer that one newly observed addresses is the result of regenerating a previously observed one.</t>

<t>The lifetime of an address should be further reduced by privacy-meaningful events. For example, a host should not employ the same address across network attachment events. That is, a host that de-attaches from a network and subsequently re-attaches to a (possibly different) network should regenerate all of its temporary addresses. Similarly, a host that implements MAC address randomization should regenerate all of its temporary addresses. Other events, such as those discussed in <xref target="privacy-reqs"/> should also trigger the regeneration of all temporary addresses.</t>

<t>The IIDs of addresses configured for different autoconfiguration prefixes must 
be different, such that traffic for those addresses cannot be correlated.</t>

<t>The reuse of identifiers that have their own semantics or properties across 
different contexts or scopes can be detrimental for security and privacy 
<xref target="I-D.gont-predictable-numeric-ids"/> <xref target="RFC6973"/> 
<xref target="RFC4941"/>. For example, if two different layer-3 protocols generate 
their addresses by embedding a layer-2 identifier (e.g., a MAC address), then the 
traffic for such protocols could be correlated (irrespective of whether the 
aforementioned layer-2 identifier has been randomized or not). Besides, a node 
that generates an IPv6 address by embedding a link-layer address in the IPv6 address 
will, when configuring addresses for different prefixes, result in the same IID being 
used for such prefixes, thus allowing the corresponding traffic to be correlated.</t>

<t>For security and privacy reasons, the IIDs generated for temporary addresses must 
not be predictable. Otherwise, the node may be subject to many (if not all) of the 
security and privacy issues that are meant to be mitigated (please see 
<xref target="RFC7721"/>.</t>

<t>Any semantics or patterns in an IID might be leveraged by an attacker to e.g. 
reduce the search space when performing address-scanning attacks, infer the 
identity of the node, etc.</t>
</section>

</section>

<section title="Generation of Temporary IPv6 Addresses" anchor="generation">
<t>The following subsections specify algorithms that may be employed to generate temporary addresses that comply with the requirements specified in <xref target="non-iid-generation"/>.</t>

<section title="RFC 4941" anchor="RFC-4941">
<t>One possible algorithm for generating temporary IPv6 addresses is that specified 
in <xref target="RFC4941"/>.</t>

<t>We note that, since the publication of <xref target="RFC4941"/>, a number of issues have been found in common implementations of such algorithm <xref target="RAID2015"/>.

<list style="hanging">
<t>
TODO: It remains an open question what to do with respect to RFC4941. If this draft was to obsolete RFC4941, instead of merely update it, we would need to include here the actual specification of the address generation algorithm.
</t>
</list>
</t>

</section>

<section title="Randomized IIDs" anchor="randomized-IIDs">
<t>Another possible approach would be to select a random IID when performing SLAAC. A node employing this algorithm should generate IIDs as follows:

<list style="numbers">
<t>Obtain a random number (see <xref target="RFC4086"/> for randomness requirements for
 security)</t>

<t>The Interface Identifier is obtained by taking as many bits from the aforementioned random number (obtained in the previous step) as necessary.

<list style="hanging">
<t>We note that <xref target="RFC4291"/> requires that the Interface
  IDs of all unicast addresses (except those that start with the
  binary value 000) be 64 bits long. However, the method discussed in this document could be employed for generating Interface IDs of any arbitrary length, albeit at the expense of reduced entropy (when employing Interface IDs smaller than 64 bits).</t>
</list>
The resulting Interface Identifier SHOULD be compared against the reserved IPv6 Interface Identifiers <xref target="RFC5453"/> <xref target="IANA-RESERVED-IID"/> and against those Interface Identifiers already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, this situation SHOULD be handled in the same way as the case of duplicate addresses.
</t>
</list>
</t>

 
<t>A node that disconnects from the network and subsequently reconnects would employ a (statistically different) IID for the same prefix. Similarly, a different (random) IID should be employed for each autoconfiguration prefix. In the event of Duplicate Address Detection (DAD) <xref target="RFC4862"/> failures, another random number should be selected to recover from the DAD failure.</t>

<!-- [fgont] I've removed this text, since this is now a formal requirement for temporary addresses

These addresses, 
as opposed to the temporary addresses specified in RFC4941, would be stable for as 
long as the node stays attached (without disconnecting) to the network, but would 
change when a node reconnects.
-->

<!-- [fgont] I've commented out this text since I've included this items in the requirements section. Please let me know whether you think these should be re-added. I think that, irrespective of whether we specifies an algorithm or not, the part of the document that specifies requirements for temporary addresses should tal about "renumbering triggering" events, etc.

<t>
<list>
<t>TODO: in addition to a generation algorithm, we need to also specify that addresses
can have a variable lifetime, instead of just using the "periodic update" specified 
in <xref target="RFC4941" />.</t>
<t>TODO: need a discussion of "renumbering trigger", such as what to do when the 
browser requires to "delete history". Such events mark the start of a "privacy epoch",
and should trigger creation of new temporary addresses and deprecation of the 
existing addresses.</t>
</list>
</t>

-->

</section>
<section title="Hash-based generation of temporary address generation" anchor="RFC-7217">

<t>The algorithm in <xref target="RFC7217"/> can be augmented for the generation of temporary addresses. The benefit of this would be that a node could employ a single algorithm for generating stable and temporary addresses, by employing appropriate parameters.</t>

<t>Nodes would employ the following algorithm for generating the temporary IID:

<list style="numbers">
<t>
Compute a random identifier with the expression:
<vspace blankLines="1" />
RID = F(Prefix, MAC_Address, Network_ID, Time, DAD_Counter, secret_key)
<vspace blankLines="1" />
Where:
<list style="hanging">
<t hangText="RID:">
<vspace blankLines="0" />Random Identifier</t>
<t hangText="F():">
<vspace blankLines="0" />A pseudorandom function (PRF) that MUST NOT be computable from the outside (without knowledge of the secret key). F() MUST also be difficult to reverse, such that it resists attempts to obtain the secret_key, even when given samples of the output of F() and knowledge
or control of the other input parameters. F() SHOULD produce an output of at least 64 bits. F() could be implemented as a cryptographic hash of the concatenation of each of the function parameters. SHA-1 <xref target="FIPS-SHS"/> and SHA-256 are two possible options for F(). Note: MD5 <xref target="RFC1321"/> is considered unacceptable for F() <xref target="RFC6151"/>.</t>
<t hangText="Prefix:">
<vspace blankLines="0" />The prefix to be used for SLAAC, as learned from an ICMPv6 Router Advertisement message, or the link-local IPv6 unicast prefix <xref target="RFC4291"/>.</t>
<t hangText="MAC_Address:">
<vspace blankLines="0" />The MAC address corresponding to the underlying network interface card. Employing the MAC address in this expression (in replacement of the Net_Iface parameter of the expression in RFC7217) means that the re-generation of a randomized MAC address will result in a different temporary address.</t>
<t hangText="Network_ID:">
<vspace blankLines="0" />Some network-specific data that identifies
the subnet to which this interface is attached -- for example, the IEEE 802.11 Service Set Identifier (SSID) corresponding to the network to which this interface is associated. Additionally, Simple DNA <xref target="RFC6059"/> describes ideas that could be leveraged to generate a Network_ID parameter. This parameter is SHOULD be employed if some form of "Network_ID" is available.</t>
<t hangText="Time:">
<vspace blankLines="0" />An implementation-dependent representation of time. One possible example is the representation in UNIX-like systems <xref target="OPEN-GROUP"/>, that measure time in terms of the number of seconds elapsed since the Epoch (00:00:00 Coordinated Universal Time (UTC), 1 January 1970).</t>

<t hangText="DAD_Counter:">
<vspace blankLines="0" />A counter that is employed to resolve Duplicate Address Detection (DAD) conflicts.<!-- It MUST be initialized to 0, and incremented by 1 for each new tentative address that is configured as a result of a DAD conflict. Implementations that record DAD_Counter in non-volatile memory for each {Prefix, Net_Iface, Network_ID} tuple MUST initialize DAD_Counter to the recorded value if such an entry exists in non-volatile memory. See <xref target="dad-conflicts"/> for additional details.--></t>
<t hangText="secret_key:">
<vspace blankLines="0" />A secret key that is not known by the
 attacker. The secret key SHOULD be of at least 128 bits. It MUST be initialized to a pseudo-random number
 (see <xref target="RFC4086"/> for randomness requirements for
 security) when the operating system is installed or when the IPv6
 protocol stack is "bootstrapped" for the first time.


<!-- An implementation MAY provide the means for the system administrator to display and change the secret key. -->
</t>
</list>
</t>

<t>The Interface Identifier is finally obtained by taking as many bits from the RID value (computed in the previous step) as necessary, starting from the least significant bit.<!--
<list style="hanging">
<t>We note that <xref target="RFC4291"/> requires that the Interface
  IDs of all unicast addresses (except those that start with the
  binary value 000) be 64 bits long. However, the method discussed in this document could be employed for generating Interface IDs of any arbitrary length, albeit at the expense of reduced entropy (when employing Interface IDs smaller than 64 bits).</t>
</list>-->
The resulting Interface Identifier SHOULD be compared against the reserved IPv6 Interface Identifiers <xref target="RFC5453"/> <xref target="IANA-RESERVED-IID"/> and against those Interface Identifiers already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, this situation SHOULD be handled in the same way as the case of duplicate addresses.
</t>
</list>
</t>

</section>

</section>

<section title="Update to existing RFCs" anchor="updated-rfcs">
<t>The following subsections clarify how each of the RFCs affected by this document 
are updated.</t>

<section title="Update to RFC4941">
<t>The temporary addresses specified in <xref target="RFC4941"/> MAY be used in 
replacement of the stable addresses <xref target="RFC8064"/>. 
That is, a node MAY configure temporary addresses only, without configuring any 
stable addresses.
</t>

</section>
</section>

	<section title="Future Work" anchor="future-work">
<t>This document clarifies the requirements for stability requirements for IPv6 
addresses, and specifies requirements for temporary addresses. A separate document (<xref target="I-D.gont-6man-address-usage-recommendations"/>) discusses the tradeoffs involved when considering 
different stability properties of IPv6 addresses, and and the different configuration 
setups such as: stable addresses only, temporary addresses only, or mixed stable and 
temporary addresses.
</t>
</section>


	<section title="IANA Considerations" anchor="iana-considerations">
<t>There are no IANA registries within this document. The RFC-Editor can remove this 
section before publication of this document as an RFC.</t>
</section>



    <section title="Security Considerations" anchor="sec-cons">
<t>This document clarifies the stability requirements for IPv6 addresses, and specifies 
requirements for the generation of temporary addresses. Additionally, it formally updates 
<xref target="RFC4941"/> such that stable addresses are not required to be configured 
along with the temporary addresses.
</t>
<t>The security and privacy properties of IPv6 addresses have been discussed in detail in <xref target="RFC7721"/> and <xref target="RFC7707"/>.</t>

    </section>


    <section title="Acknowledgements">
<t>The authors would like to thank (in alphabetical order) Brian Carpenter and 
Lorenzo Colitti for providing valuable feedback on earlier versions of this document.</t>
    </section>
  </middle>




  <back>
  <references title='Normative References'>
	<?rfc include="reference.RFC.2119" ?>
<!-- CH: commenting out two orphan references
	<?rfc include="reference.RFC.2460" ?>
	<?rfc include="reference.RFC.4291" ?>
-->
	<?rfc include="reference.RFC.4862" ?>
	<?rfc include="reference.RFC.4291" ?>
	<?rfc include="reference.RFC.4941" ?>
	<?rfc include="reference.RFC.7217" ?>
	<?rfc include="reference.RFC.8064" ?>

<!-- Added as a result of algorithm specification -->
	<?rfc include="reference.RFC.4086" ?>
	<?rfc include="reference.RFC.5453" ?>
	<?rfc include="reference.RFC.7136" ?>

  </references>

  <references title='Informative References'>

	<?rfc include="reference.I-D.gont-predictable-numeric-ids" ?>
	<?rfc include="reference.I-D.gont-6man-address-usage-recommendations" ?>

	<?rfc include="reference.RFC.6973" ?>
        <?rfc include="reference.RFC.7258" ?>
        <?rfc include="reference.RFC.7624" ?>
	<?rfc include="reference.RFC.7721" ?>
        <?rfc include="reference.RFC.7844" ?>

<reference anchor="RTB25" target="http://www.iab.com/wp-content/uploads/2016/03/OpenRTB-API-Specification-Version-2-5-FINAL.pdf">
  <front>
    <title>Real Time Bidding (RTB) project, OpenRTB API Specification Version 2.5</title>
    <author>
      <organization>Interactive Advertising Bureau (IAB)</organization>
    </author>
    <date year="2016" month="December"/>
  </front>
</reference>

<reference anchor="IETFMACRandom" target="http://www.ietf.org/blog/2014/11/mac-privacy/" >
<front>
<title>MAC Privacy</title>
<author initials="JC." surname="Zuniga" fullname="Juan Carlos Zuniga">
      <organization/>
</author>
<date year="2014" month="November"/>
</front>
</reference>

      <reference anchor="RAID2015" target="https://www.sba-research.org/wp-content/uploads/publications/Ullrich2015Privacy.pdf">
        <front>
          <title>Privacy is Not an Option: Attacking the IPv6 Privacy Extension</title>

          <author fullname="Johanna Ullrich" initials="J." surname="Ullrich">
          </author>

          <author fullname="Edgar R. Weippl" initials="E.R." surname="Weippl">
          </author>
          <date/>
        </front>

        <seriesInfo name=""
                    value="International Symposium on Recent Advances in Intrusion Detection (RAID), 2015"/>
      </reference>
	<?rfc include="reference.RFC.7707" ?>


<!-- Added as a result of algorithm specification -->
	<?rfc include="reference.RFC.6059" ?>

	<reference anchor="IANA-RESERVED-IID" target="http://www.iana.org/assignments/ipv6-interface-ids">
		<front>
			<title>Reserved IPv6 Interface Identifiers</title>
			<author>
				<organization>IANA</organization>
			</author>
			<date/>
		</front>
	</reference>

	<?rfc include="reference.RFC.1321" ?>
	<?rfc include="reference.RFC.6151" ?>

	<reference anchor="FIPS-SHS" target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
		<front>
			<title>Secure Hash Standard (SHS)</title>

    <author>
		<organization>NIST</organization>
    </author>  

			<date month="March" year="2012"/>
		</front>
		<seriesInfo name="FIPS Publication" value="180-4"/>
	</reference>

	<reference anchor="OPEN-GROUP" target="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html">
		<front>
			<title>The Open Group Base Specifications Issue 7 / IEEE Std 1003.1-2008, 2016 Edition</title>

    <author>
		<organization>The Open Group</organization>
    </author>  

			<date year="2016"/>
		</front>
		<seriesInfo name="Section 4.16" value="Seconds Since the Epoch"/>
	</reference>


</references>
  </back>
</rfc>
